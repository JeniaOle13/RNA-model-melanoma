---
title: "Bulk RNA-seq analysis of mice model melanoma"
format: html
editor: visual
---
# Material and methods
<p style="text-align: justify;">
Quality control of experimental mice transcriptomics data was performed using [FastQC](https://github.com/s-andrews/FastQC) (v0.12.1). [MultiQC](https://github.com/MultiQC/MultiQC) tool was used for aggregation of `FastQC` reports [Ewels et al., 2016]. The [fastp](https://github.com/OpenGene/fastp) (v0.23.4) was used to filter out low-quality reads [Chen et al., 2018]. Read alignment was performed by [STAR](https://github.com/alexdobin/STAR) (v2.7.11) [Dobin et al., 2013] using the *Mus musculus* reference genome downloaded from [GENCODE](https://www.gencodegenes.org/mouse/) `GRCm39.vM36` and the `gtf` file `gencode.vM36.chr_patch_hapl_scaff.annotation.gtf`. Count of gene expression profiles was performed using [HTSeq count](https://github.com/simon-anders/htseq) (v2.0.5) [Anders et al., 2015]. Differential expression analysis between experimental groups was performed using [DESeq2](https://github.com/thelovelab/DESeq2) (v1.44.0) [Love et al., 2014]. Gene-set enrichment analysis (`GSEA`) was performed using [fgsea](https://github.com/alserglab/fgsea) (v1.31.6) [Korotkevich et al., 2016] and [clusterProfiler](https://guangchuangyu.github.io/software/clusterProfiler/) (v4.12.6) [Wu et al., 2021] approaches using the following databases: [MSigDB](https://www.gsea-msigdb.org/gsea/msigdb) [Castanza et al., 2023]. Mapping gene identifiers between different coding systems was performed by [biomaRt](https://github.com/grimbough/biomaRt) package. To perform the `GSEA` analysis using immune cells markers, a [CellMarker 2.0](http://www.bio-bigdata.center/) database were used [Hu et al., 2023]. Gene set variation analysis [GSVA](https://github.com/rcastelo/GSVA) was used for estimating immune cell type enrichment within samples [Hänzelmann et al., 2013]. Co-expression analysis was performed using [BioNERO](https://github.com/almeidasilvaf/BioNERO) (v1.12.0) [Almeida-Silva et al., 2022] with signed hybrid network type and Pearson correlation. Correction of expression data by differentiation method batch was performed using `removeBatchEffect` function from [limma](https://kasperdanielhansen.github.io/genbioconductor/html/limma.html) package [Ritchie et al., 2015]. Over-representation analysis for functional analysis of co-expressed gene modules linked to experimental groups using `clusterProfiler` package with `MSigDB`, [KEGG](https://www.genome.jp/kegg/) [Kanehisa et al., 2025], [Reactome](https://reactome.org/) [Milacic et al., 2024] and [WikiPathways](https://www.wikipathways.org/) [Agrawal et al., 2024]. [STRING](https://string-db.org/) database and [STRINGdb](https://www.bioconductor.org/packages/release/bioc/html/STRINGdb.html) Bioconductor package were used for construction of interaction networks linked to genes included to co-expressed gene modules [Szklarczyk et al., 2023]. For visualization of obtained results [pheatmap](https://github.com/raivokolde/pheatmap) (v1.0.12), [ggplot2](https://ggplot2.tidyverse.org/]) (v3.5.1) and [EnhancedVolcano](https://github.com/kevinblighe/EnhancedVolcano) packages were used. Data analysis were implemented in [R](https://www.r-project.org/) (v4.4.2).
</p>

```{mermaid}
flowchart LR
    A[("Raw reads")] --> B{"fastp"}
    B --> C{"FastQC"} & E{"STAR"}
    C --> D{"MultiQC"}
    E --> F{"HTSeq"}
    F --> G[("Count table")]
    G --> I{"DESeq2"} & Z{"limma"} & W{"PCA"}
    Z --> H{"PCA"} & J{"BioNERO"}
    I --> K{"GSEA"}
    J --> L{"ORA"} & N{"STRING"}
    G --> V{"GSVA"}

     A:::Aqua
     B:::Aqua
     B:::Pine
     C:::Pine
     E:::Pine
     D:::Pine
     F:::Pine
     G:::Aqua
     I:::Pine
     Z:::Pine
     W:::Pine
     H:::Pine
     J:::Pine
     K:::Pine
     L:::Pine
     N:::Pine
     V:::Pine
    classDef Aqua stroke-width:1px, stroke-dasharray:none, stroke:#46EDC8, fill:#DEFFF8, color:#378E7A
    classDef Pine stroke-width:1px, stroke-dasharray:none, stroke:#254336, fill:#27654A, color:#FFFFFF
```

## References
1) [Ewels, Philip, et al. "MultiQC: summarize analysis results for multiple tools and samples in a single report." Bioinformatics 32.19 (2016): 3047-3048.](https://academic.oup.com/bioinformatics/article/32/19/3047/2196507)

2) [Chen, Shifu, et al. "fastp: an ultra-fast all-in-one FASTQ preprocessor." Bioinformatics 34.17 (2018): i884-i890.](https://academic.oup.com/bioinformatics/article/34/17/i884/5093234)

3) [Dobin, Alexander, et al. "STAR: ultrafast universal RNA-seq aligner." Bioinformatics 29.1 (2013): 15-21.](https://academic.oup.com/bioinformatics/article/29/1/15/272537)

4) [Anders, Simon, Paul Theodor Pyl, and Wolfgang Huber. "HTSeq—a Python framework to work with high-throughput sequencing data." Bioinformatics 31.2 (2015): 166-169](https://academic.oup.com/bioinformatics/article/31/2/166/2366196)

5) [Love, Michael I., Wolfgang Huber, and Simon Anders. "Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2." Genome biology 15 (2014): 1-21.](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-014-0550-8)

6) [Hu, Congxue, et al. "CellMarker 2.0: an updated database of manually curated cell markers in human/mouse and web tools based on scRNA-seq data." Nucleic acids research 51.D1 (2023): D870-D876.](https://academic.oup.com/nar/article/51/D1/D870/6775381)

7) [Hänzelmann, Sonja, Robert Castelo, and Justin Guinney. "GSVA: gene set variation analysis for microarray and RNA-seq data." BMC bioinformatics 14 (2013): 1-15.](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-14-7)

8) [Almeida-Silva, Fabricio, and Thiago M. Venancio. "BioNERO: an all-in-one R/Bioconductor package for comprehensive and easy biological network reconstruction." Functional & Integrative Genomics 22.1 (2022): 131-136.](https://link.springer.com/article/10.1007/s10142-021-00821-9)

9) [Ritchie, Matthew E., et al. "limma powers differential expression analyses for RNA-sequencing and microarray studies." Nucleic acids research 43.7 (2015): e47-e47.](https://academic.oup.com/nar/article/43/7/e47/2414268)

11) [Kanehisa, Minoru, et al. "KEGG: biological systems database as a model of the real world." Nucleic Acids Research 53.D1 (2025): D672-D677.](https://academic.oup.com/nar/article/53/D1/D672/7824602)

12) [Milacic, Marija, et al. "The reactome pathway knowledgebase 2024." Nucleic acids research 52.D1 (2024): D672-D678.](https://academic.oup.com/nar/article/52/D1/D672/7369850)

13) [Agrawal, Ayushi, et al. "WikiPathways 2024: next generation pathway database." Nucleic acids research 52.D1 (2024): D679-D689.](https://academic.oup.com/nar/article/52/D1/D679/7369835)

14) [Szklarczyk, Damian, et al. "The STRING database in 2023: protein–protein association networks and functional enrichment analyses for any sequenced genome of interest." Nucleic acids research 51.D1 (2023): D638-D646.](https://academic.oup.com/nar/article/51/D1/D638/6825349)

## Database links
GENCODE: <https://www.gencodegenes.org/mouse/>

MSigDB: <https://www.gsea-msigdb.org/gsea/msigdb>

KEGG: <https://www.genome.jp/kegg/>

Reactome: <https://reactome.org/>

Wiki pathways: <https://www.wikipathways.org/>

CellMarker: <http://www.bio-bigdata.center/>

STRING: <https://string-db.org/>

## Tool links
FastQC: <https://github.com/s-andrews/FastQC>

MultiQC: <https://github.com/MultiQC/MultiQC>

fastp: <https://github.com/OpenGene/fastp>

STAR: <https://github.com/alexdobin/STAR>

HTSeq: <https://github.com/simon-anders/htseq>

DESeq2: <https://github.com/thelovelab/DESeq2>

fgsea: <https://github.com/alserglab/fgsea>

clusterProfiler: <https://guangchuangyu.github.io/software/clusterProfiler/>

GSVA: <https://bioconductor.org/packages/release/bioc/html/GSVA.html>

biomaRt: <https://github.com/grimbough/biomaRt>

BioNERO: <https://github.com/almeidasilvaf/BioNERO>

limma: <https://bioconductor.org/packages/release/bioc/html/limma.html>

STRINGdb: <https://www.bioconductor.org/packages/release/bioc/html/STRINGdb.html>

pheatmap: <https://github.com/raivokolde/pheatmap>

ggplot2: <https://github.com/tidyverse/ggplot2>

EnhancedVolcano: <https://github.com/kevinblighe/EnhancedVolcano>

R: <https://www.r-project.org/>

# Results

```{r}
#| label: Import libraries
#| message: false
#| warning: false
#| include: false

library(vegan)
library(fgsea)
library(limma)
library(stringr)
library(BioNERO)
library(DESeq2)
library(tidyverse)
library(factoextra)
library(clusterProfiler)

library(ggpubr)
library(ggplot2)
library(pheatmap)
library(RColorBrewer)
library(ComplexHeatmap)
library(EnhancedVolcano)

library(DOSE)
library(msigdbr)
library(msigdbdf)
library(biomaRt)
library(ReactomePA)
library(org.Mm.eg.db)
library(AnnotationDbi)
library(AnnotationHub)
library(GSVA)
library(STRINGdb)
library(immunedeconv)

library(DT)
library(downloadthis)

mypal <- brewer.pal(8, "Set1")

set.seed(10)
```

```{r}
#| label: Import data
#| message: false
#| warning: false
#| include: false

meta_data <- read.csv("data/metadata.tsv", sep = "\t")
meta_data$group <- as.factor(meta_data$group)
meta_data$batch <- as.factor(meta_data$batch)
meta_data$File <- meta_data$sampleid
meta_data <- meta_data[c(1,4,2,3)]
meta_data$File <- paste0(meta_data$File, ".counts")

reads.counts <- read.csv("data/counts.tsv", sep = "\t")
colnames(reads.counts)[3] <- "filtered"
colnames(reads.counts)[4] <- "%_filtered"
reads.counts <- merge(meta_data[c(1,3)], reads.counts, by = 1)

ddsHTSeq <- DESeqDataSetFromHTSeqCount(sampleTable = meta_data,
                                       directory = "data/htseq/",
                                       design= ~ 0 + group + batch)
rownames(ddsHTSeq) <- sapply(str_split(rownames(ddsHTSeq), "\\."), function(x) x[1])

ENTREZID <- mapIds(org.Mm.eg.db, keys = rownames(ddsHTSeq), keytype="ENSEMBL", column = "ENTREZID")
ENTREZID <- as.data.frame(ENTREZID)
ENTREZID <- cbind(rownames(ENTREZID), ENTREZID)
colnames(ENTREZID)[1] <- "ENSEMBL"

SYMBOL <- mapIds(org.Mm.eg.db, keys = rownames(ddsHTSeq), keytype="ENSEMBL", column = "SYMBOL")
SYMBOL <- as.data.frame(SYMBOL)
SYMBOL <- cbind(rownames(SYMBOL), SYMBOL)
colnames(SYMBOL)[1] <- "ENSEMBL"

convertID <- merge(SYMBOL, ENTREZID)
```

## Samples and experimental groups
<p style="text-align: justify;">
A total of 14 transcriptomic samples corresponding to the following three experimental groups: melanoma (n=6) and melanoma with *Bifidobacterium adolescentis* 150 supplement (n=6) and melanoma with *Lacticaseibacillus rhamnosus* K32 supplement (n=2) were added to the analysis (see Table 1). The experiment was performed in two replicates: first included only melanoma and melanoma with *B. adolescentis* supplement groups; second included all three experimental groups. To simplify the description of the results, we adopted the following codings:
<p>

Experimental groups: 

1) Melanoma --> `M`

2) Melanoma with *B. adolescentis* supplement --> `M_BIF`

3) Melanoma with *L. rhamnosus* supplement --> `M_LAC`

Experimental batch:

1) First experiment --> `batch_1`

2) Second experiment --> `batch_2`

```{r}
#| label: Metadata table
#| echo: false
meta_data_d <- meta_data[order(meta_data$group),]
meta_data_d$batch <- paste0("batch_", meta_data_d$batch)

datatable(meta_data[-2], 
          caption = "Table 1. Samples metadata.",
          style = "bootstrap5", 
          extensions = 'Buttons', 
          options = list(dom = 'lBfrtip',
                         buttons = c('csv', 'excel')))
```

## Quality control
<p style="text-align: justify;">
After quality filtering using `fastp`, `MultiQC` was used for aggregate `FastQC` reports. Figure 1 shows the summary `MultiQC` quality assessment profile which shows that the sequencing data have a average quality. In summary, after quality filtering, ~ 198 million reads (14 $\pm$ 5 per sample) added to further analysis. In average 16 $\pm$ 7% per sample were filtered. Quality filtering statistic showed in Table 2. HTSeq tool were used for gene expression statistic counting. Figure 3 showed HTSeq counts across experimental samples. No statistically significant differences in the number of reads were found between the experimental groups. However, different batches statistically significantly differed in the read counts (see Figure 3). The gene expression counts table normalized by [median of ratios method](https://hbctraining.github.io/DGE_workshop/lessons/02_DGE_count_normalization.html) is presented in Table 4.
<p>

#### MiltiQC report
[MultiQC full report](multiqc_report.html)

![Figure 1. Summary MultiQC report.](fastqc-status-check-heatmap.svg)

#### Reads filtering by quality statistic
```{r}
#| label: fastp filtered table
#| echo: false
datatable(reads.counts, 
          caption = "Table 2. Reads filtering statistic.",
          style = "bootstrap5", 
          extensions = 'Buttons', 
          options = list(dom = 'lBfrtip',
                         buttons = c('csv', 'excel')))
```

#### Mapping reads to reference counts
```{r}
#| label: HTSeq count plot
#| echo: false

counts.df <- as.data.frame(round(colSums(counts(ddsHTSeq))/1000000, 2))
counts.df <- cbind(sampleid = rownames(counts.df), counts.df)
colnames(counts.df)[2] <- "counts"

counts.df <- merge(meta_data[-2], counts.df, by = 1)

counts_plot <- ggplot(counts.df, aes(counts, reorder(sampleid, counts), fill = group))+
    geom_bar(stat = "identity")+
    theme_bw()+
    scale_fill_brewer(palette = "Set1")+
    xlab("Reads counts, mln")+
    ylab("Sample ID")+
    theme(legend.position = "bottom")
```

```{r fig.height=7, fig.width=5}
#| label: HTSeq count plot download
#| echo: false
download_this(
  counts_plot,
  output_name = "counts_plot",
  output_extension = ".pdf",
  button_label = "PDF",
  button_type = "primary"
)
```

```{r fig.height=7, fig.width=5}
#| label: HTSeq count plot draw
#| echo: false
#| fig-cap: Figure 3. Barplot denoted HTSeq counts per experimantal sample.
counts_plot
```

#### ANOVA
```{r}
#| label: HTSeq ANOVA
#| echo: false
#| message: false
#| warning: false

counts.aov <- aov(counts ~ batch + group, counts.df)
summary(counts.aov)
```

#### Normalized counts table
```{r}
#| label: Normalizaed counts table
#| echo: false
#| message: false
#| warning: false
# Filter gene table by counts
keep <- rowSums(counts(ddsHTSeq)>= 10) > ncol(ddsHTSeq)*0.3
ddsHTSeq <- ddsHTSeq[keep,]

ddsHTSeq <- DESeq(ddsHTSeq)

COU <- counts(ddsHTSeq, normalized = T)

COU.add <- merge(convertID[c(1,2)], cbind(rownames(COU), COU), by = 1)

datatable(COU.add, 
          caption = "Table 3. Normalized counts table.",
          style = "bootstrap5", 
          extensions = 'Buttons', 
          options = list(dom = 'lBfrtip',
                         buttons = c('csv', 'excel')))
```

## Principal component analysis
<p style="text-align: justify;">
Principal component analysis ([PCA](https://en.wikipedia.org/wiki/Principal_component_analysis)) is a linear dimensional reduction technique with applications in exploratory data analysis and visualization. Before performing a `PCA`, expression data were transformed by variance-stabilizing transformation. This function calculates a variance stabilizing transformation ([VST](https://en.wikipedia.org/wiki/Variance-stabilizing_transformation)) from the fitted dispersion-mean relation(s) and then transforms the count data (normalized by division by the size factors or normalization factors), yielding a matrix of values which are now approximately homeostatic (having constant variance along the range of mean values). The transformation also normalizes with respect to library size. The bi-dimensional visualization using the first two components presented in Figure 4. Proportion of explained variance across principal components presented in Figure 5. According to analysis of variance using permutations ([PERMANOVA](https://en.wikipedia.org/wiki/Permutational_analysis_of_variance)) expression profiles statistical significant links to batch but not linked to experimental groups.
<p>

```{r}
#| label: PCA 1
#| echo: false
# Make PCA visualization
vsd <- as.data.frame(assay(vst(ddsHTSeq)))

PCA <- prcomp(t(vsd))
PCA.points <- as.data.frame(PCA$x)
PCA.points <- merge(meta_data, cbind(rownames(PCA.points), PCA.points), by = 1)[-2]

PCA_plot <- ggplot(PCA.points, aes(PC1, PC2, col = group, shape = batch))+
    geom_point(size = 2.75)+
    # geom_text(size = 3)+
    theme_bw()+
    theme(legend.position = "right")+
    scale_color_brewer(palette = "Set1")+
    xlab("PC1")+
    ylab("PC2")

prop_plot <- fviz_eig(PCA, col.var="blue") + ggtitle("Proportion of explained variance")
```

```{r fig.height=4, fig.width=5}
#| label: PCA 2
#| echo: false
download_this(
  PCA_plot,
  output_name = "PCA_plot",
  output_extension = ".pdf",
  button_label = "PDF",
  button_type = "primary"
)
```

```{r fig.height=4, fig.width=5}
#| label: PCA 3
#| echo: false
#| fig-cap: Figure 4. PCA visualization using regularized log transformation counts.
PCA_plot
```

```{r fig.height=4, fig.width=5}
#| label: Exp variance plot 20
#| echo: false
download_this(
  prop_plot,
  output_name = "prop_plot",
  output_extension = ".pdf",
  button_label = "PDF",
  button_type = "primary"
)
```

```{r fig.height=4, fig.width=5}
#| label: Exp variance plot 30
#| echo: false
#| fig-cap: Figure 5. The proportion of explained variance of each component.
prop_plot
```

```{r}
#| label: PERMANOVA 10
#| echo: false
#| message: true
#| warning: false
PERMANOVA <- adonis2(t(vsd) ~  batch + group, data = meta_data, permutations = 9999, by = "margin", method = "euclidean")
PERMANOVA
```

## Differential expression analysis
<p style="text-align: justify;">
Differential expression analysis was performed using DESeq2 package with formula `~ batch + group` for controlling dispersion linked to batch. Positive `lfc` and `NES` values in differential expression and `GSEA` analysis linked to *B. adolescentis* 150 and *L. rhamnosus* K32 supplement groups as well as negative values to `melanoma` group without any interventions. The [`DESeq2`](https://bioconductor.org/packages/3.21/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) package allows to estimate differential gene expression by constructing generalized linear models for the negative binomial distribution and analyzing linear contrasts between compared groups. According to obtained results 3 genes were up-regulated as well as 16 down-regulated in `M_BIF` group in comparison with `M` group. At the same time, 21 genes were linked to `M_LAC` groups while 0 genes linked to `M` group in comparison to `M_LAC`. When comparing bacteria supplement groups among themselves, 39 genes were linked to `M_BIF` whereas 116 genes were linked to `M_LAC`. Differentially represented genes were identified using the following significance thresholds adj. p \< 0.05, \|lfc\| \> 1. Differential analysis statistic presented in Tables 4-6. Visualization of differential expression genes of p-value - log FC measure presented via volcano plots (see Figures 6-8).
<p>

```{r}
#| label: DEG table 1
#| echo: false
#| message: false
#| warning: false
# Make DEG tables
get_DEG <- function(res){
    # DEG <- cbind(as.data.frame(res), COU)
    DEG <- as.data.frame(res)
    DEG <- DEG[!is.na(DEG$padj),]
    # DEG <- DEG[order(DEG$log2FoldChange, decreasing = T),]
    return(DEG)
}

contr_1 <- makeContrasts(groupM_BIF - groupM, levels = resultsNames(ddsHTSeq))
contr_2 <- makeContrasts(groupM_LAC - groupM, levels = resultsNames(ddsHTSeq))
contr_3 <- makeContrasts(groupM_BIF - groupM_LAC, levels = resultsNames(ddsHTSeq))

res_1 <- results(ddsHTSeq, contrast=contr_1)
res_2 <- results(ddsHTSeq, contrast=contr_2)
res_3 <- results(ddsHTSeq, contrast=contr_3)

DEG_BIF <- get_DEG(res_1)
DEG_LAC <- get_DEG(res_2)
DEG_BIF_LAC <- get_DEG(res_3)

DEG_BIF_add <- merge(convertID[-3], cbind(rownames(DEG_BIF), DEG_BIF), by = 1)
DEG_LAC_add <- merge(convertID[-3], cbind(rownames(DEG_LAC), DEG_LAC), by = 1)
DEG_BIF_LAC_add <- merge(convertID[-3], cbind(rownames(DEG_BIF_LAC), DEG_BIF_LAC), by = 1)

DEG_BIF_add <- DEG_BIF_add[order(DEG_BIF_add$log2FoldChange, decreasing = T),]
rownames(DEG_BIF_add) <- 1:nrow(DEG_BIF_add)

DEG_LAC_add <- DEG_LAC_add[order(DEG_LAC_add$log2FoldChange, decreasing = T),]
rownames(DEG_LAC_add) <- 1:nrow(DEG_LAC_add)

DEG_BIF_LAC_add <- DEG_BIF_LAC_add[order(DEG_BIF_LAC_add$log2FoldChange, decreasing = T),]
rownames(DEG_BIF_LAC_add) <- 1:nrow(DEG_BIF_LAC_add)
```

```{r}
#| label: Volcano plots
#| echo: false
#| message: false
#| warning: false
VolcanoPlot1 <- EnhancedVolcano(DEG_BIF_add,
                lab = DEG_BIF_add$SYMBOL,
                x = 'log2FoldChange', 
                y = 'padj', pCutoff = 0.05, 
                subtitle = "", 
                title = "", 
                ###########################
                # labSize = 4,
                drawConnectors = TRUE, 
                # widthConnectors = 0.75, 
                gridlines.major = FALSE, 
                gridlines.minor = FALSE)

VolcanoPlot2 <- EnhancedVolcano(DEG_LAC_add,
                lab = DEG_LAC_add$SYMBOL,
                x = 'log2FoldChange', 
                y = 'padj', pCutoff = 0.05, 
                subtitle = "", 
                title = "", 
                ###########################
                # labSize = 4,
                drawConnectors = TRUE, 
                # widthConnectors = 0.75, 
                gridlines.major = FALSE, 
                gridlines.minor = FALSE)

VolcanoPlot3 <- EnhancedVolcano(DEG_BIF_LAC_add,
                lab = DEG_BIF_LAC_add$SYMBOL,
                x = 'log2FoldChange', 
                y = 'padj', pCutoff = 0.05, 
                subtitle = "", 
                title = "", 
                ###########################
                # labSize = 4,
                drawConnectors = TRUE, 
                # widthConnectors = 0.75, 
                gridlines.major = FALSE, 
                gridlines.minor = FALSE)
```

#### M_BIF vs M
```{r}
#| echo: false
#| message: false
#| warning: false
datatable(DEG_BIF_add, 
          caption = "Table 4. Differential expression analysis results: M_BIF vs M.",
          style = "bootstrap5", 
          extensions = 'Buttons', 
          options = list(dom = 'lBfrtip', 
              buttons = c('csv', 'excel')))
```

```{r fig.height=8, fig.width=7}
#| label: Volcano plot 1
#| echo: false
#| message: false
#| warning: false
download_this(
  VolcanoPlot1,
  output_name = "VolcanoPlot",
  output_extension = ".pdf",
  button_label = "PDF",
  button_type = "primary"
)
```

```{r fig.height=8, fig.width=7}
#| echo: false
#| message: false
#| warning: false
#| fig-cap: "Figure 6. Volcano plot denoted differential expressed genes: M_BIF vs M."
VolcanoPlot1
```

#### M_LAC vs M
```{r}
#| echo: false
#| message: false
#| warning: false
datatable(DEG_LAC_add, 
          caption = "Table 5. Differential expression analysis results: M_LAC vs M.",
          style = "bootstrap5", 
          extensions = 'Buttons', 
          options = list(dom = 'lBfrtip', 
              buttons = c('csv', 'excel')))
```

```{r fig.height=8, fig.width=7}
#| label: Volcano plot 2
#| echo: false
#| message: false
#| warning: false
download_this(
  VolcanoPlot2,
  output_name = "VolcanoPlot",
  output_extension = ".pdf",
  button_label = "PDF",
  button_type = "primary"
)
```

```{r fig.height=8, fig.width=7}
#| echo: false
#| message: false
#| warning: false
#| fig-cap: "Figure 7. Volcano plot denoted differential expressed genes: M_LAC vs M."
VolcanoPlot2
```

#### M_BIF vs M_LAC
```{r}
#| echo: false
#| message: false
#| warning: false
datatable(DEG_BIF_LAC_add, 
          caption = "Table 6. Differential expression analysis results: M_BIF vs M_LAC.",
          style = "bootstrap5", 
          extensions = 'Buttons', 
          options = list(dom = 'lBfrtip', 
              buttons = c('csv', 'excel')))
```

```{r fig.height=8, fig.width=7}
#| label: Volcano plot 3
#| echo: false
#| message: false
#| warning: false
download_this(
  VolcanoPlot3,
  output_name = "VolcanoPlot",
  output_extension = ".pdf",
  button_label = "PDF",
  button_type = "primary"
)
```

```{r fig.height=8, fig.width=7}
#| echo: false
#| message: false
#| warning: false
#| fig-cap: "Figure 8. Volcano plot denoted differential expressed genes: M_BIF vs M_LAC."
VolcanoPlot3
```

## Gene set enrichment analysis
<p style="text-align: justify;">
Gene Set Enrichment Analysis ([GSEA](https://en.wikipedia.org/wiki/Gene_set_enrichment_analysis)) is a computational method that determines whether an a prior defined set of genes shows statistically significant, concordant differences between two biological states (e.g. phenotype). Several databases were used to conduct the GSEA analysis, which allowed us to identify a wide range of biological functions associated with experimental groups. [MSigDB hallmark](https://www.gsea-msigdb.org/gsea/msigdb/collections.jsp) gene-set were used for this analysis. The obtained results presented in Figure 9 and Tables 7-9. To identify specific expression markers characteristic of different cell types, a [Cell Marker 2.0](http://www.bio-bigdata.center/) database for mouse was used (see Figure 10 and Tables 10-12).
<p>

#### MSigDb Hallmark
```{r}
#| label: GSEA
#| message: false
#| warning: false
#| include: false
pathwaysH <- msigdbr("mouse", category="H")
pathwaysH.sbs <- split(as.character(pathwaysH$ensembl_gene), pathwaysH$gs_name)

get_ranks <- function(DEG){
    DEG$log2FoldChange[DEG$log2FoldChange > 0] <- 1
    DEG$log2FoldChange[DEG$log2FoldChange < 0] <- -1
    ranks.df <- -log10(DEG$pvalue)*DEG$log2FoldChange
    names(ranks.df) <- rownames(DEG)
    # names(ranks.df) <- sapply(str_split(names(ranks.df), "\\."), function(x) x[1])    
    ranks.df <- sort(ranks.df, decreasing = T)
    return(ranks.df)
}

ranks.bif <- get_ranks(DEG_BIF)
ranks.lac <- get_ranks(DEG_LAC)
ranks.bif.lac <- get_ranks(DEG_BIF_LAC)

fgsea.bif <- fgsea(pathways = pathwaysH.sbs, 
                  stats    = ranks.bif,
                  eps      = 0.0,
                  minSize  = 15,
                  maxSize  = 500)

fgsea.lac <- fgsea(pathways = pathwaysH.sbs, 
                     stats    = ranks.lac,
                     eps      = 0.0,
                     minSize  = 15,
                     maxSize  = 500)

fgsea.bif.lac <- fgsea(pathways = pathwaysH.sbs, 
                   stats    = ranks.bif.lac,
                   eps      = 0.0,
                   minSize  = 15,
                   maxSize  = 500)

filter_pval <- function(fgsea, NES, padj){
    fgsea <- as.data.frame(fgsea)
    fgsea <- fgsea[fgsea$padj < padj,]
    fgsea <- fgsea[abs(fgsea$NES) > NES,]
    fgsea <- fgsea[order(fgsea$NES, decreasing = T),]
    return(fgsea)
}

fgsea.bif.filter <- filter_pval(fgsea.bif, 1, 0.01)
rownames(fgsea.bif.filter) <- 1:nrow(fgsea.bif.filter)

fgsea.lac.filter <- filter_pval(fgsea.lac, 1, 0.01)
rownames(fgsea.lac.filter) <- 1:nrow(fgsea.lac.filter)

fgsea.bif.lac.filter <- filter_pval(fgsea.bif.lac, 1, 0.01)
rownames(fgsea.bif.lac.filter) <- 1:nrow(fgsea.bif.lac.filter)

get_subset <- function(df, group){
    df.sbs <- df[c(1,6)]
    df.sbs$group <- group
    return(df.sbs)
}

fgsea.bif.sbs <- get_subset(fgsea.bif.filter, "M+BIF vs M")
fgsea.lac.sbs <- get_subset(fgsea.lac.filter, "M+LAC vs M ")
fgsea.bif.lac.sbs <- get_subset(fgsea.bif.lac.filter, "M+BIF vs M+LAC")

fgsea.all <- rbind(fgsea.bif.sbs, fgsea.lac.sbs, fgsea.bif.lac.sbs)
fgsea.all <- spread(fgsea.all, group, NES, fill = 0)
rownames(fgsea.all) <- fgsea.all$pathway
fgsea.all <- fgsea.all[-1]

heatmap.hallmark <- pheatmap::pheatmap(as.matrix(fgsea.all), cutree_rows = 7, cutree_cols = 2, display_numbers = T)
```

##### M_BIF vs M
```{r}
#| echo: false
datatable(fgsea.bif.filter[-8], 
          caption = "Table 7. GSEA analysis results obtained using MSigDB: M_BIF vs M.",
          style = "bootstrap5", 
          extensions = 'Buttons', 
          options = list(dom = 'lBfrtip',
                         buttons = c('csv', 'excel')))
```

##### M_LAC vs M
```{r}
#| echo: false
datatable(fgsea.lac.filter[-8], 
          caption = "Table 8. GSEA analysis results obtained using MSigDB: M_LAC vs M.",
          style = "bootstrap5", 
          extensions = 'Buttons', 
          options = list(dom = 'lBfrtip',
                         buttons = c('csv', 'excel')))
```

##### M_BIF vs M_LAC
```{r}
#| echo: false
datatable(fgsea.bif.lac.filter[-8], 
          caption = "Table 9. GSEA analysis results obtained using MSigDB: M_BIF vs M_LAC.",
          style = "bootstrap5", 
          extensions = 'Buttons', 
          options = list(dom = 'lBfrtip',
                         buttons = c('csv', 'excel')))
```

```{r fig.width=7, fig.height=10}
#| echo: false
#| message: false
#| warning: false
#| fig-cap: "Figure 9. Heatmap denoted NES values of MSigDB Hallmark pathways linked to experimental groups."
heatmap.hallmark
```

#### Cell Marker 2.0
```{r}
#| message: false
#| warning: false
#| include: false
cell_marker_data <- read.csv("data/cell_marker_mouse.csv",sep = "\t")
cell_names <- unique(cell_marker_data$cell_name)

cells <- cell_marker_data %>%
    dplyr::select(cell_name, GeneID)

t_cells <- cell_names[!is.na(str_extract(cell_names, "T cell"))]
b_cells <- cell_names[!is.na(str_extract(cell_names, "B cell"))]
neutrophil <- cell_names[!is.na(str_extract(cell_names, "Neutrophil|neutrophil"))]
dendritic_cell <- cell_names[!is.na(str_extract(cell_names, "Dendritic|dendritic"))]
basophil <- cell_names[!is.na(str_extract(cell_names, "Basophil|basophil"))]
mast_cell <- cell_names[!is.na(str_extract(cell_names, "Mast|mast"))]
macrophage <- cell_names[!is.na(str_extract(cell_names, "Macrophage|macrophage"))]
# histiocyte <- cell_names[!is.na(str_extract(cell_names, "Histiocyte|histiocyte"))]
kupffer_cell <- cell_names[!is.na(str_extract(cell_names, "Kupffer|kupffer"))]
plasma_cell <- cell_names[!is.na(str_extract(cell_names, "plasma|Plasma"))]
innate_lymphoid <- cell_names[!is.na(str_extract(cell_names, "Innate|Lymphoid|innate|lymphoid"))]
NK <- cell_names[!is.na(str_extract(cell_names, "NK|natural killer"))]

lymphocyte <- cell_names[!is.na(str_extract(cell_names, "Lymphocyte|lymphocyte"))]
monocyte <- cell_names[!is.na(str_extract(cell_names, "Monocyte|monocyte"))]
granulocyte <- cell_names[!is.na(str_extract(cell_names, "Granulocyte|granulocyte"))]

immune.cells <- unique(c(t_cells, b_cells, neutrophil, dendritic_cell, basophil, mast_cell, 
         macrophage, kupffer_cell, plasma_cell, innate_lymphoid, NK, 
         lymphocyte, monocyte, granulocyte))

ens2ent <- mapIdscell_nameens2ent <- mapIds(org.Mm.eg.db, keys = rownames(COU), keytype="ENSEMBL", column = "ENTREZID")
ens2ent <- as.data.frame(ens2ent)
ens2ent <- cbind(ENSEMBL = rownames(ens2ent), ENTREZID = ens2ent$ens2ent)
row.names(ens2ent) <- 1:nrow(ens2ent)

get_ENTREZID_rank <- function(rank.df, ens2ent){
    rank.df <- merge(ens2ent, cbind(names(rank.df), rank.df), by = 1)
    rank.df <- rank.df[!is.na(rank.df$ENTREZID),]
    rank.df <- rank.df[!duplicated(rank.df$ENTREZID),]
    
    rank.ent <- as.numeric(rank.df$rank.df)
    names(rank.ent) <- rank.df$ENTREZID
    rank.ent <- sort(rank.ent, decreasing = T)
    return(rank.ent)
}

ranks.bif.ent <- get_ENTREZID_rank(ranks.bif, ens2ent)
ranks.lac.ent <- get_ENTREZID_rank(ranks.lac, ens2ent)
ranks.bif.lac.ent <- get_ENTREZID_rank(ranks.bif.lac, ens2ent)

get_GSEA <- function(ranks.df, TERM2GENE, 
                     eps, pvalueCutoff, minGSSize, maxGSSize){
    gsea.df <- GSEA(ranks.df, TERM2GENE = TERM2GENE, eps = eps, 
                      pvalueCutoff = pvalueCutoff, minGSSize = minGSSize, 
                      maxGSSize = maxGSSize)
    gsea.df <- as.data.frame(gsea.df)
    gsea.df <- gsea.df[abs(gsea.df$NES) > 1,]
    return(gsea.df)
}

set.seed(100)
cells.bif <- get_GSEA(ranks.bif.ent, TERM2GENE = cells[cells$cell_name %in% immune.cells,],
         eps = 0, pvalueCutoff = 0.05, minGSSize = 20, maxGSSize = 500)
cells.lac <- get_GSEA(ranks.lac.ent, TERM2GENE = cells[cells$cell_name %in% immune.cells,],
                      eps = 0, pvalueCutoff = 0.05, minGSSize = 20, maxGSSize = 500)
cells.bif.lac <- get_GSEA(ranks.bif.lac.ent, TERM2GENE = cells[cells$cell_name %in% immune.cells,],
                      eps = 0, pvalueCutoff = 0.05, minGSSize = 20, maxGSSize = 500)

get_subset2 <- function(df, group){
    df.sbs <- df[c(1,5)]
    df.sbs$group <- group
    return(df.sbs)
}

cells.bif.sbs <- get_subset2(cells.bif, "M+BIF vs M")
cells.lac.sbs <- get_subset2(cells.lac, "M+LAC vs M")
cells.bif.lac.sbs <- get_subset2(cells.bif.lac, "M+BIF vs M+LAC")

cells.all <- rbind(cells.bif.sbs, cells.lac.sbs, cells.bif.lac.sbs)
cells.all.s <- spread(cells.all, ID, NES, fill =  0)
rownames(cells.all.s) <- cells.all.s$group
cells.all.s <- cells.all.s[-1]

cells.bif_add <- cells.bif
rownames(cells.bif_add) <- 1:nrow(cells.bif_add)
cells.bif_add <- cells.bif_add[-c(1,10:11)]
cells.bif_add <- cells.bif_add[order(cells.bif_add$NES, decreasing = T),]

cells.lac_add <- cells.lac
rownames(cells.lac_add) <- 1:nrow(cells.lac_add)
cells.lac_add <- cells.lac_add[-c(1,10:11)]
cells.lac_add <- cells.lac_add[order(cells.lac_add$NES, decreasing = T),]

cells.bif.lac_add <- cells.bif.lac
rownames(cells.bif.lac_add) <- 1:nrow(cells.bif.lac_add)
cells.bif.lac_add <- cells.bif.lac_add[-c(1,10:11)]
cells.bif.lac_add <- cells.bif.lac_add[order(cells.bif.lac_add$NES, decreasing = T),]

heatmap.immune.gsea <- pheatmap::pheatmap(t(cells.all.s), display_numbers = T, cutree_rows = 4)
```

##### M_BIF vs M
```{r}
#| echo: false
datatable(cells.bif_add, 
          caption = "Table 10. GSEA analysis results obtained using Cell Marker 2.0: M_BIF vs M.",
          style = "bootstrap5", 
          extensions = 'Buttons', 
          options = list(dom = 'lBfrtip',
                         buttons = c('csv', 'excel')))
```

##### M_LAC vs M
```{r}
#| echo: false
datatable(cells.lac_add, 
          caption = "Table 11. GSEA analysis results obtained using Cell Marker 2.0: M_LAC vs M.",
          style = "bootstrap5", 
          extensions = 'Buttons', 
          options = list(dom = 'lBfrtip',
                         buttons = c('csv', 'excel')))
```

##### M_BIF vs M_LAC
```{r}
#| echo: false
datatable(cells.bif.lac_add, 
          caption = "Table 12. GSEA analysis results obtained using Cell Marker 2.0: M_BIF vs M_LAC.",
          style = "bootstrap5", 
          extensions = 'Buttons', 
          options = list(dom = 'lBfrtip',
                         buttons = c('csv', 'excel')))
```

```{r fig.width=5, fig.height=7}
#| echo: false
#| message: false
#| warning: false
#| fig-cap: "Figure 10. Heatmap denoted NES values of immune cell types linked to experimental groups."
heatmap.immune.gsea
```

## Prediction of immune cell counts

#### Mmcp counter (T cell)
```{r}
#| message: false
#| warning: false
#| include: false
exp.data <- vst(counts(ddsHTSeq))
immune_cells <- deconvolute_mmcp_counter(exp.data, log2 = F, genome = "GCRm39", gene_id = "ENSEMBL.ID")

column.annot <- meta_data
rownames(column.annot) <- column.annot$sampleid
column.annot <- column.annot[-c(1,2)]
column.annot$batch <- as.factor(column.annot$batch)

annot.colors <- list(group=c(M=mypal[1], M_BIF = mypal[2], M_LAC = mypal[3]),
                     batch = c(`1` = "darkred", `2` = "darkblue"))

heatmap.immune <- pheatmap::pheatmap(log(immune_cells+0.001),
                                     scale = "column",
                                     annotation_col = column.annot,
                                     cutree_cols = 4, cutree_rows = 6,
                                     annotation_colors = annot.colors,
                                     show_colnames = F)

immune_cells.df <- as.data.frame(t(immune_cells))
immune_cells.df <- merge(meta_data, cbind(rownames(immune_cells.df), immune_cells.df), by = 1)[-2]
immune_cells.df$`T cells` <- rank(immune_cells.df$`T cells`)

my_comparison <- list(c("M", "M_BIF"), c("M", "M_LAC"), c("M_BIF", "M_LAC"))

tcells_boxplot <- ggplot(immune_cells.df, aes(group, `T cells`, fill = group))+
    geom_boxplot()+
    theme_bw()+
    theme(legend.position = "none")+
    scale_fill_brewer(palette = "Set1")+
    # stat_compare_means(comparisons = my_comparison)+
    xlab("Mmcp counter T cells score")+
    ylab("Group")
```

```{r fig.height=4, fig.width=7}
#| eval: false
#| message: false
#| warning: false
#| fig-cap: "Figure 11. Heatmap denoted Mmcp counter values of immune cell types linked to experimental groups."
#| include: false
heatmap.immune
```

```{r fig.width=3, fig.height=4}
#| echo: false
#| message: false
#| warning: false
#| fig-cap: "Figure 12. Boxplot showed Mmcp counter predicted T cell values in experimental groups."
tcells_boxplot
```

```{r}
#| label: Mmcp counter ANOVA
#| echo: false
#| message: true
#| warning: false
summary(aov(`T cells` ~ group + batch, data = immune_cells.df))
```

#### GSVA
```{r}
#| message: false
#| warning: false
#| include: false
df.Symbol <- as.data.frame(counts(ddsHTSeq))
df.Symbol <- merge(convertID[c(1,3)], cbind(rownames(df.Symbol), df.Symbol), by = 1)
df.Symbol <- df.Symbol[!is.na(df.Symbol$ENTREZID),]
df.Symbol <- df.Symbol[!duplicated(df.Symbol$ENTREZID),]
df.Symbol <- df.Symbol[-1]

rownames(df.Symbol) <- df.Symbol$ENTREZID
df.Symbol <- df.Symbol[-1]
```

##### Macrophage
```{r}
#| include: false
macro_sets <- list(
    M1 = cell_marker_data$GeneID[cell_marker_data$cell_name == "M1 macrophage"],
    M2 = cell_marker_data$GeneID[cell_marker_data$cell_name == "M2 macrophage"]
)

gsvapar <- gsvaParam(as.matrix(df.Symbol), macro_sets)
ssgsea_scores <- gsva(gsvapar)

ssgsea_results <- as.data.frame(t(ssgsea_scores))

ssgsea_results$M1_M2_ratio <- ssgsea_results$M1 / ssgsea_results$M2
ssgsea_results <- merge(meta_data, cbind(rownames(ssgsea_results), ssgsea_results), by = 1)[-2]

ssgsea_results$M1 <- rank(ssgsea_results$M1)
ssgsea_results$M2 <- rank(ssgsea_results$M2)
ssgsea_results$M1_M2_ratio <- rank(ssgsea_results$M1_M2_ratio)

M1_boxplot <- ggplot(ssgsea_results, aes(group, M1, fill = group))+
    geom_boxplot()+
    theme_bw()+
    theme(legend.position = "none")+
    scale_fill_brewer(palette = "Set1")+
    # stat_compare_means(comparisons = my_comparison)+
    ylab("M1 counts")+
    xlab("Group")

M2_boxplot <- ggplot(ssgsea_results, aes(group, M2, fill = group))+
    geom_boxplot()+
    theme_bw()+
    theme(legend.position = "none")+
    scale_fill_brewer(palette = "Set1")+
    # stat_compare_means(comparisons = my_comparison)+
    ylab("M2 counts")+
    xlab("Group")

M1_M2_ratio_boxplot <- ggplot(ssgsea_results, aes(group, M1_M2_ratio, fill = group))+
    geom_boxplot()+
    theme_bw()+
    theme(legend.position = "none")+
    scale_fill_brewer(palette = "Set1")+
    # stat_compare_means(comparisons = my_comparison)+
    ylab("M1/M2 ratio counts")+
    xlab("Group")
```

```{r fig.width=3, fig.height=4}
#| echo: false
#| message: false
#| warning: false
#| fig-cap: "Figure 13. Boxplot showed GSVA predicted counts of M1 macrophage in experimental groups."
M1_boxplot
```

```{r}
#| label: GSVA M1 ANOVA
#| echo: false
#| message: true
#| warning: false
summary(aov(M1 ~ group + batch, data = ssgsea_results))
```

```{r fig.width=3, fig.height=4}
#| echo: false
#| message: false
#| warning: false
#| fig-cap: "Figure 14. Boxplot showed GSVA predicted counts of M2 macrophage in experimental groups."
M2_boxplot
```

```{r}
#| label: GSVA M2 ANOVA
#| echo: false
#| message: true
#| warning: false
summary(aov(M2 ~ group + batch, data = ssgsea_results))
```

```{r fig.width=3, fig.height=4}
#| echo: false
#| message: false
#| warning: false
#| fig-cap: "Figure 15. Boxplot showed GSVA predicted counts of M1/M2 macrophage ratio in experimental groups."
M1_M2_ratio_boxplot
```

```{r}
#| label: GSVA M1/M2 ratio ANOVA
#| echo: false
#| message: true
#| warning: false
summary(aov(M1_M2_ratio ~ group + batch, data = ssgsea_results))
```

##### CD8+
```{r}
#| include: false
CD8 <- cell_marker_data$GeneID[cell_marker_data$cell_name == "CD8+ T cell"]
CD8 <- CD8[!is.na(CD8)]

CD8_sets <- list(
    CD8 = CD8
)

gsvapar_2 <- gsvaParam(as.matrix(df.Symbol), CD8_sets)
ssgsea_scores_2 <- gsva(gsvapar_2)
ssgsea_scores_2 <- as.data.frame(t(ssgsea_scores_2))

ssgsea_scores_2 <- merge(meta_data, cbind(rownames(ssgsea_scores_2), ssgsea_scores_2), by = 1)[-2]
ssgsea_scores_2$CD8 <- rank(ssgsea_scores_2$CD8)

CD8_boxplot <- ggplot(ssgsea_scores_2, aes(group, CD8, fill = group))+
    geom_boxplot()+
    theme_bw()+
    theme(legend.position = "none")+
    scale_fill_brewer(palette = "Set1")+
    # stat_compare_means(comparisons = my_comparison)+
    ylab("CD8+ counts")+
    xlab("Group")
```

```{r fig.width=3, fig.height=4}
#| echo: false
#| message: false
#| warning: false
#| fig-cap: "Figure 16. Boxplot showed GSVA predicted counts of CD8+ T cells in experimental groups."
CD8_boxplot
```

```{r}
#| label: GSVA CD8 ANOVA
#| echo: false
#| message: true
#| warning: false
summary(aov(CD8 ~ group + batch, data = ssgsea_scores_2))
```

## Co-expression analysis

# Discussion